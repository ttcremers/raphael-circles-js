var BackgroundBubble = (function(vec, paper, radius) {
  var randomINTBetween = function(min, max) {
    return Math.floor(Math.random()*(max-min+1)+min);
  };

  // Fixed properties
  var _vec = vec;
  var _paper = paper;
  var _radius = radius;
  var _decorativePosition = randomINTBetween(1, 360); 
  
  /**
    * Helper function to make it easy to get a world point on 
    * the circomference of the circle by just specifying at 
    * which degree you'd like to know the coordinates
    *
    * @returns a vector (x,y)
    */
  var getCircumWorldCoordsByDegrees = function(degrees, spacing) {
    var spacing = spacing || 0;
    return {
      x: (_radius * Math.cos(degrees * Math.PI / 180.0) + _vec.x) + spacing,
      y: (_radius * Math.sin(degrees * Math.PI / 180.0) + _vec.y) + spacing
    };
  };
  
  var drawDecortiveCircles = function(parentCircle) {
    var degrees = _decorativePosition; 
    // FIXME the hardcoded radius of 200 should be refactored out
    var scale = parentCircle.attrs.r / 200;

    // Small
    var v1 = getCircumWorldCoordsByDegrees(degrees);
    var c1 = _paper.circle(
        v1.x, 
        v1.y, 
        8 * scale);
    c1.attr('stroke', "#89cff0");
    c1.attr('fill', "#FFF");

    // Medium
    degrees += ( 8 * scale );
    var v2 = getCircumWorldCoordsByDegrees(degrees);
    var c2 = _paper.circle(
        v2.x, 
        v2.y, 
        16 * scale);
    c2.attr('stroke', "#89cff0");
    c2.attr('fill', "#FFF");
    
    // Large
    degrees += ((8 * scale) + (5 * scale));
    var v3 = getCircumWorldCoordsByDegrees(degrees);
    var c3 = _paper.circle(
        v3.x, 
        v3.y, 
        24 * scale);
    c3.attr('stroke', "#89cff0");
    c3.attr('fill', "#FFF");
  };
    

  return {
    update: function(vec) { 
      if ( vec ) {
        _vec = vec; 
      }
    },
    
    render: function() {
      var circle = _paper.circle(
          _vec.x, 
          _vec.y, 
          _radius);
      circle.attr('fill-opacity', 0);
      circle.attr('stroke', "#89cff0");
      console.log(circle);
      drawDecortiveCircles(circle);
    },

    getCircumWorldCoordsByDegrees: getCircumWorldCoordsByDegrees
    
  };
});

var SmartBubble = (function(vec, paper, baseRadius, percent, growRate) {
  // Fixed properties
  var _paper            = paper;
  var _baseRadius       = baseRadius;
  var _growRate         = growRate;
  var _vec              = vec;
  var _percent          = percent;
  var _initialTextColor = "#89cff0"
  var _targetTextColor  = "#FFF"
  var _targetFillColor  = "#FFF"
  var _initialFillColor = "#89cff0"
 
  // Calculated based on percentages
  var _initialRadius = baseSize + (baseSize * percent); 
  var _initialFontSize = 12 + (12 * percent);  

  var _StatesEnum = {
    MOUSEOVER: 0,
    MOUSEOUT: 1
  };
  var _state = _StatesEnum.MOUSEOUT;

  // Calculated in render loop
  var _renderState = {
    radiusSize: _initialRadius,
    fontSize: _initialFontSize,
    textColor: "#89cff0",
    fillColor: "#FFF"
  };
  that
  var onmouseover = function() {
    _state = _StatesEnum.MOUSEOVER;
  };
  var onmouseout = function() {
    _state = _StatesEnum.MOUSEOUT;
  };

  return {
    update: function(distance) {
      /* update internal properties */
      switch (_state) {
        case _StatesEnum.MOUSEOVER:
          var targetSize = _initialRadius + (_initialRadius * growRate);
          if ( _renderState.radiusSize < targetSize ) {
            _renderState.radiusSize += distance;  
          } 
          break;

        case _StatesEnum.MOUSEOUT:
          var targetSize = _initialRadius + (_initialRadius * growRate);
          // SVG doesn't like -0 values so let's make sure we'll never hit that
          var sizeToBe = _renderState.radiusSize - distance;
          if ( sizeToBe > targetSize ) {
            _renderState.radiusSize = sizeToBe;  
          } 
          break;
      }
    },
    render: function() {
      /* render out the graphic to main paper */
      var circle = _paper.circle(
          _vec.x, 
          _vec.y, 
          _renderState.radiusSize);
      circle.attr('fill', _renderState.fillColor);

      circle.mouseover(onmouseover);
      circle.mouseout(onmouseout);
      circle.toFront(); 
      
      var text = _paper.text(vec.x, vec.y, text);
      txt.attr('fill', _renderState.textColor);
      txt.attr('font-size', _renderState.fontSize);
    }
  };
});


// size/property tracking object
var FrameAgnosticProperties = (function() {
  var registry = [];
  var fap = {};

  fap.newSize = function(radius) {
    var size = radius;
    var targetSize = radius;
    var obj =  {
      getSize: function() {
        return size; 
      },
      setSize: function(s) {
        size = s;
      },
      setTargetSize: function(s) {
        targetSize = s;
      },
      getTargetSize: function() {
        return targetSize; 
      }    
    };
    registry.push(obj);
    return obj;
  };

  fap.getOrCreateSize = function(id, radius) {
    if ( typeof registry[id] === 'undefined' ) {
      return fap.newSize(radius); 
    } 
    return registry[id];
  };

  fap.getSizeForID = function(id) {
    return registry[id]; 
  };

  fap.getAllSizes = function() {
    return registry; 
  };

  return fap;
})();

// Main module implementation (which we be moved out of this file)
var circleGridModule = function(brwsrViewPortX, brwsrViewPortY, width, height) {
  if ( typeof Raphael === 'undefined' ) {
    throw "CircleGrid depends on Raphael.js"; 
  }

  // Creates an SVG canvas
  var _paper = Raphael(brwsrViewPortX, brwsrViewPortX, width, height);
  var _circles = [];

  var circleGrid = {};
  circleGrid.internalCounter = 0; // Used for creating internal circle ID

  // Returns a circle object
  circleGrid.createCircle = function(vec, radius, fill, stroke) {
    var circle = {
      vec: vec,
      radius: radius,
      id: circleGrid.internalCounter
    }; 

    /**
     * Helper function to make it easy to get a world point on 
     * the circomference of the circle by just specifying at 
     * which degree you'd like to know the coordinates
     *
     * @returns a vector (x,y)
     */
    circle.getCircumWorldCoordsByDegrees = function(degrees, spacing) {
      var spacing = spacing || 0;
      return {
        x: (radius * Math.cos(degrees * Math.PI / 180.0) + circle.vec.x) +spacing,
        y: (radius * Math.sin(degrees * Math.PI / 180.0) + circle.vec.y) +spacing
      };
    };
    
    circle.element = _paper.circle(circle.vec.x, circle.vec.y, radius);
    
    if ( typeof fill !== 'undefined' ) {
      circle.element.attr("fill", fill);
    } else {
      circle.element.attr("fill", '#FFF');
    }
    
    if ( typeof stroke !== 'undefined' ) {
      circle.element.attr("stroke", stroke);
    } else {
      // Default stroke color is black
      circle.element.attr("stroke", '#000');
    }
    circle.fill =  circle.element.attr("fill");
    circle.stroke = circle.element.attr("stroke"); 

    circle.isDrawn = true;

    // Remeber the circle
    _circles[circleGrid.internalCounter] = circle;
    circleGrid.internalCounter++;
    
    return circle;
  };

  circleGrid.getAllCircles = function() {
    return _circles;  
  };
  
  circleGrid.getMainPaper = function() {
    return _paper;  
  };

  circleGrid.drawAll = function() {
    for (var i = 0; i < _circles.length; i++) {
      c = _circles[i];
      c.draw();
    }
  };
  
  circleGrid.resetInternalCounter = function() {
    circleGrid.internalCounter = 0;
  }

  return circleGrid;
};

