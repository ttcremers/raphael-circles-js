<!DOCTYPE html>
<html>
<head>
	<title>Circles</title>
	<script type="text/javascript" src="./raphael.js"></script>
		
</head>
<body>

<script type="text/javascript" src="./main.js"></script>

<script>

  // shim layer with setTimeout fallback
  (function() {
      var lastTime = 0;
      var vendors = ['ms', 'moz', 'webkit', 'o'];
      for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
          window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
          window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] 
                                    || window[vendors[x]+'CancelRequestAnimationFrame'];
      }
  
      if (!window.requestAnimationFrame)
          window.requestAnimationFrame = function(callback, element) {
              var currTime = new Date().getTime();
              var timeToCall = Math.max(0, 16 - (currTime - lastTime));
              var id = window.setTimeout(function() { callback(currTime + timeToCall); }, 
                timeToCall);
              lastTime = currTime + timeToCall;
              return id;
          };
  
      if (!window.cancelAnimationFrame)
          window.cancelAnimationFrame = function(id) {
              clearTimeout(id);
          };
  }());
 
  
  var mainPaper = Raphael(0, 0, 1280, 750); 
  var centerVector = {}; 
  centerVector.x = Math.round(mainPaper.width / 2);
  centerVector.y = Math.round(mainPaper.height / 2);
  

  var levelDefinition = {
    bubbles: [
      {type: 'BackgroundBubble', args: [centerVector, mainPaper, 200], 
        bubbles: [ 
          { type: 'BackgroundBubble', args: [0, mainPaper, 200] } 
        ]}, 
    ]  
  };


  var App = {
    objectStore: [],

    init: function(mainPaper, levelDefinition) {
      // Generate all objects
      var that = this;
      var bubbleLevel = 0;
      (function levelGenerate(bubbles, parentID) {
        for (var i = 0; i < bubbles.length; i++) {
          var b = bubbles[i];
          that.objectStore.push(
              { 
                bubble: window[b.type].apply(null, b.args),
                parentID: parentID,
                position: b.args.shift()
              }
          );
          
          // Recurse if needed
          if ( typeof b.bubbles !== 'undefined' ) {
            levelGenerate(b.bubbles, that.objectStore.length); 
          }
        }
      })(levelDefinition.bubbles, 0);

      // We need to reverse the data set or else 
      // we run into problems calculating vectors
      // later on
      this.objectStore.reverse();

      this.frame(); // This starts the game loop
    },

    frame: function() {
      App.setDelta();
      App.update();
      App.render();
      App.animationFrame = window.requestAnimationFrame(App.frame);
    },

    setDelta: function() {
      App.now = Date.now();
      if ( typeof App.then !== 'undefined' ) {
        App.delta = (App.now - App.then) / 1000; // seconds since last frame
      } else {
        App.delta = 0;
      }
      App.then = App.now;
    },

    update: function() {
      for (var i = 0; i < this.objectStore.length; i++) {
        var obj = this.objectStore[i];
        if ( typeof obj.position === 'object' ) {
          obj.bubble.update(obj.position); 
        } else {
          obj.bubble.update(
              this.objectStore[obj.parentID].bubble.getCircumWorldCoordsByDegrees(obj.position)
              ); 
        }
      }
    },

    render: function() {
      mainPaper.clear(); // clean our stage
      for (var i = 0; i < this.objectStore.length; i++) {
        var obj = this.objectStore[i];
        obj.bubble.render();
      } 
    }
  
  };

  App.init(mainPaper, levelDefinition);
  
</script>
</body>
</html>
